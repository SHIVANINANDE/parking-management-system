# Logstash Pipeline Configuration for Parking Management System

input {
  # Receive logs from Filebeat
  beats {
    port => 5044
  }
  
  # Direct log inputs for testing
  tcp {
    port => 5000
    codec => json
  }
  
  # UDP input for syslog
  udp {
    port => 5000
    codec => json
  }
}

filter {
  # Parse timestamp field
  if [@timestamp] {
    date {
      match => [ "@timestamp", "ISO8601" ]
    }
  }
  
  # Handle Docker container logs
  if [container] {
    # Extract service name from container name
    if [container][name] {
      grok {
        match => { "[container][name]" => "/(?<service_name>[a-zA-Z0-9_-]+)" }
      }
    }
    
    # Parse application logs
    if [service_name] =~ /parking/ {
      # Parse structured JSON logs
      if [message] =~ /^\{/ {
        json {
          source => "message"
          target => "app_log"
        }
        
        # Extract log level
        if [app_log][level] {
          mutate {
            add_field => { "log_level" => "%{[app_log][level]}" }
          }
        }
        
        # Extract correlation ID for tracing
        if [app_log][correlation_id] {
          mutate {
            add_field => { "correlation_id" => "%{[app_log][correlation_id]}" }
          }
        }
        
        # Extract request information
        if [app_log][request_id] {
          mutate {
            add_field => { "request_id" => "%{[app_log][request_id]}" }
          }
        }
        
        if [app_log][endpoint] {
          mutate {
            add_field => { "api_endpoint" => "%{[app_log][endpoint]}" }
          }
        }
        
        if [app_log][method] {
          mutate {
            add_field => { "http_method" => "%{[app_log][method]}" }
          }
        }
        
        if [app_log][status_code] {
          mutate {
            add_field => { "http_status" => "%{[app_log][status_code]}" }
          }
        }
        
        if [app_log][duration_seconds] {
          mutate {
            add_field => { "response_time" => "%{[app_log][duration_seconds]}" }
          }
        }
        
        # Parse error information
        if [app_log][error] {
          mutate {
            add_field => { "error_message" => "%{[app_log][error]}" }
          }
        }
        
        if [app_log][error_type] {
          mutate {
            add_field => { "error_type" => "%{[app_log][error_type]}" }
          }
        }
        
        if [app_log][traceback] {
          mutate {
            add_field => { "stack_trace" => "%{[app_log][traceback]}" }
          }
        }
      }
    }
  }
  
  # Parse Nginx access logs
  if [service_name] =~ /nginx/ or [fields][service] == "nginx" {
    grok {
      match => { 
        "message" => "%{COMBINEDAPACHELOG}"
      }
    }
    
    # Parse response time if present
    grok {
      match => { 
        "message" => ".*request_time:(?<nginx_response_time>[0-9.]+)"
      }
    }
    
    # Convert response time to float
    if [nginx_response_time] {
      mutate {
        convert => { "nginx_response_time" => "float" }
      }
    }
    
    # Classify slow requests
    if [nginx_response_time] and [nginx_response_time] > 2.0 {
      mutate {
        add_tag => [ "slow_request" ]
      }
    }
  }
  
  # Parse PostgreSQL logs
  if [service_name] =~ /postgres/ {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{POSINT:pid}\] %{WORD:log_level}: %{GREEDYDATA:postgres_message}"
      }
    }
    
    # Parse slow query logs
    if [postgres_message] =~ /duration:/ {
      grok {
        match => { 
          "postgres_message" => "duration: (?<query_duration>[0-9.]+) ms.*statement: (?<sql_statement>.*)"
        }
      }
      
      if [query_duration] {
        mutate {
          convert => { "query_duration" => "float" }
        }
        
        # Tag slow queries
        if [query_duration] > 1000 {
          mutate {
            add_tag => [ "slow_query" ]
          }
        }
      }
    }
  }
  
  # Parse Redis logs
  if [service_name] =~ /redis/ {
    grok {
      match => { 
        "message" => "%{POSINT:pid}:%{CHAR:role} %{TIMESTAMP_ISO8601:timestamp} %{CHAR:level} %{GREEDYDATA:redis_message}"
      }
    }
  }
  
  # Common field enrichment
  # Normalize log levels
  if [log_level] {
    translate {
      field => "log_level"
      destination => "severity"
      dictionary => {
        "DEBUG" => "debug"
        "INFO" => "info"
        "WARNING" => "warn"
        "ERROR" => "error"
        "CRITICAL" => "fatal"
        "FATAL" => "fatal"
      }
      fallback => "unknown"
    }
  }
  
  # Add environment information
  mutate {
    add_field => { 
      "environment" => "${ENVIRONMENT:development}"
      "cluster" => "${CLUSTER_NAME:parking-cluster}"
    }
  }
  
  # Extract IP geolocation for security analysis
  if [clientip] {
    geoip {
      source => "clientip"
      target => "geoip"
      add_tag => [ "geoip" ]
    }
  }
  
  # Security filters
  # Detect potential security threats
  if [message] =~ /(?i)(sql injection|xss|csrf|script|alert|eval|union|select.*from)/  {
    mutate {
      add_tag => [ "security_threat", "potential_attack" ]
      add_field => { "security_risk" => "high" }
    }
  }
  
  # Detect failed authentication attempts
  if [message] =~ /(?i)(authentication failed|login failed|invalid credentials|unauthorized)/ {
    mutate {
      add_tag => [ "auth_failure" ]
    }
  }
  
  # Performance analysis
  # Tag slow operations
  if [response_time] {
    if [response_time] > 5.0 {
      mutate {
        add_tag => [ "very_slow" ]
      }
    } else if [response_time] > 2.0 {
      mutate {
        add_tag => [ "slow" ]
      }
    }
  }
  
  # Error classification
  if [severity] == "error" or [severity] == "fatal" {
    mutate {
      add_tag => [ "error" ]
    }
    
    # Classify error types
    if [error_type] {
      if [error_type] =~ /(?i)(timeout|connection)/ {
        mutate {
          add_tag => [ "infrastructure_error" ]
        }
      } else if [error_type] =~ /(?i)(validation|value|type)/ {
        mutate {
          add_tag => [ "application_error" ]
        }
      }
    }
  }
  
  # Remove unnecessary fields to reduce storage
  mutate {
    remove_field => [ "agent", "ecs", "host.mac" ]
  }
}

output {
  # Main Elasticsearch output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "parking-logs-%{+YYYY.MM.dd}"
    
    # Template for index mapping
    template => "/usr/share/logstash/templates/parking-logs.json"
    template_name => "parking-logs"
    template_overwrite => true
    
    # Document type based on service
    document_type => "%{[service_name]}"
  }
  
  # Separate index for errors
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "parking-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Separate index for security events
  if "security_threat" in [tags] or "auth_failure" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "parking-security-%{+YYYY.MM.dd}"
    }
  }
  
  # Performance monitoring index
  if "slow" in [tags] or "very_slow" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "parking-performance-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output for troubleshooting (only in development)
  if "${ENVIRONMENT:development}" == "development" {
    stdout {
      codec => rubydebug
    }
  }
}
